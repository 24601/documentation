---
Заголовок: «Datadog»
MetaTitle: «Интеграция Datadog»
MetaDescription: «Как интегрировать Datadog с OpenReplay и просматривать ошибки бэкенда вместе с записями сеансов»
---

Как интегрировать Datadog с OpenReplay и просматривать ошибки бэкенда вместе с записями сеансов.

## 1. Создание ключа API и ключа приложения Datadog

Перейдите на страницу [Datadog > Integrations > APIs](https://app.datadoghq.com/account/settings#api) и создайте ключ API или используйте существующий.

![Ключ API Datadog](/static/datadog-1.png#center)

На той же странице нажмите на кнопку «Ключи приложения» и создайте новый ключ приложения.

![Ключ приложения Datadog](/static/datadog-2.png#center)

## 2. Включение интеграции в OpenReplay

Вставьте ваш ключ `API` и ключ `Application` в Datadog в панели управления OpenReplay в разделе «Настройки > Интеграция».

![Интеграция Datadog в OpenReplay](/static/datadog-3.png#center)

## 3. Распространение openReplaySessionToken

Для связывания события Datadog с записанным сеансом пользователя необходимо передать уникальный токен из вашего фронтенда в ваш бэкенд при каждом запросе, который вы хотите отслеживать. Это можно сделать с помощью пользовательского заголовка HTTP. В приведенном ниже примере мы используем функцию `fetch`, чтобы отправить этот заголовок.


```javascript
const headers = {
  Accept: 'application/json',
  'Content-Type': 'application/json',
};
if (tracker.getSessionToken()) { // or window.OpenReplay instead of tracker if you're using the snippet
  headers['X-OpenReplay-SessionToken'] = tracker.getSessionToken(); // Inject openReplaySessionToken
}
fetch('www.your-backend.com', {
  'GET',
  headers,
});
```


Для того, чтобы OpenReplay связал запись журнала Datadog с записанным сеансом пользователя, необходимо передать уникальный токен к каждой ошибке бэкенда, которую вы хотите отслеживать.

Ниже приведен пример на Python с использованием монкет-патчинга.


```python
import sys
import traceback
#...
old_tb = traceback.print_exception
old_f = sys.stdout
old_e = sys.stderr
OPENREPLAY_SESSION_TOKEN = None

class F:
    def write(self, x):
        if OPENREPLAY_SESSION_TOKEN is not None and x != '\n':
            old_f.write(f"[openReplaySessionToken={OPENREPLAY_SESSION_TOKEN}] {x}")
        else:
            old_f.write(x)

    def flush(self):
        pass

def tb_print_exception(etype, value, tb, limit=None, file=None, chain=True):
    if OPENREPLAY_SESSION_TOKEN is not None:
        value = type(value)(f"[openReplaySessionToken={OPENREPLAY_SESSION_TOKEN}] " + str(value))
    old_tb(etype, value, tb, limit, file, chain)

traceback.print_exception = tb_print_exception

sys.stderr = F()
```

