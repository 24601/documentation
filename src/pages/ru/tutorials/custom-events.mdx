Заголовок: «Использование пользовательских событий для улучшения отслеживания»
MetaTitle: «Улучшите свою способность отслеживания с помощью пользовательских событий и пользовательских проблем»
MetaDescription: «Захватите все виды пользовательских событий с помощью API пользовательских событий»

Пользовательские события - это простая и мощная концепция, которую наш Трекер предоставляет без дополнительных действий.
Они могут расширить отслеживаемые данные тем, что вам нужно, будь то пользовательские ошибки, связанные с вашей бизнес-логикой, или даже простые события, чтобы быть в курсе того, что делают ваши пользователи.

Наш трекер по умолчанию будет следить за многими разными вещами, в том числе за некоторыми [полезными ошибками], но они могут не быть достаточно для вас, поэтому у нас есть пользовательские события.

## Добавление пользовательских событий

Для этого примера возьмем обычный электронный магазин и добавим некоторые события, чтобы понять, когда наш пользователь добавляет продукт в корзину.

По умолчанию OpenReplay не будет отслеживать эту информацию. Однако с помощью пользовательских событий вы можете легко следить за этим.

Для этого учебника мы будем использовать проект Next.js, настроенный по той же архитектуре, что и в [учебнике Next.js], поэтому не стесняйтесь проверять его, если вы еще этого не сделали.

### Создание провайдера трекера

Логика внутри этого файла полностью объяснена в [этом учебнике].

Все, что вам нужно знать сейчас, это то, что это контекстный провайдер, который мы создаем, позволяющий вам взаимодействовать с трекером с помощью нескольких функций.

В частности, мы будем заботиться о `logIssue` и `logEvent`, которые позволяют отправить пользовательскую проблему или событие на платформу.

- **События** предназначены для записи действий, специфичных для пользователя. В нашем случае, например, мы будем записывать добавление продукта в корзину.
- **Проблемы**, с другой стор
```jsx
import { createContext, useCallback } from 'react'
import Tracker from '@openreplay/tracker'
import { v4 as uuidV4 } from 'uuid'
import { useReducer } from 'react'

export const TrackerContext = createContext()
function defaultGetUserId() {
  return uuidV4()
}
function newTracker(config) {
  const getUserId =
    config?.userIdEnabled && config?.getUserId
      ? config.getUserId
      : defaultGetUserId
  let userId = null
  const trackerConfig = {
    projectKey:
      config?.projectKey || process.env.NEXT_PUBLIC_OPENREPLAY_PROJECT_KEY,
 
  }
  if (config?.ingestPoint || process.env.NEXT_PUBLIC_OPENREPLAY_INGEST_POINT) {
    trackerConfig.ingestPoint =
      config?.ingestPoint || process.env.NEXT_PUBLIC_OPENREPLAY_INGEST_POINT
  }

  console.log('Tracker configuration: ')
  console.log(trackerConfig)
  const tracker = new Tracker(trackerConfig)
  if (config?.userIdEnabled) {
    userId = getUserId()
    tracker.setUserID(userId)
  }
  return tracker
}
function reducer(state, action) {
  switch (action.type) {
    case 'init': {
      if (!state.tracker) {
        console.log('Instantiaing the tracker for the first time...')
        let t = newTracker(state.config)
        let pluginsReturnedValue = {}
        if (state.config.plugins) {
          state.config.plugins.forEach((p) => {
            console.log('Using plugin...')
            pluginsReturnedValue[p.name] = t.use(p.fn(p.config))
          })
        }
        return {
          ...state,
          pluginsReturnedValue: pluginsReturnedValue,
          tracker: t,
        }
      }
      return state
    }
    case 'start': {
      console.log('Starting tracker...')
      state.tracker.start()
      return state
    }
    case 'logEvent': {
      console.log('Logging event')
      state.tracker?.event(action.payload?.name, action.payload?.data)
      return state
    }
    case 'logIssue': {
      console.log('Logging issue')
      state.tracker?.issue(action.payload?.name, action.payload?.data)
      return state
    }
  }
}
export default function TrackerProvider({ children, config = {} }) {
  let [state, dispatch] = useReducer(reducer, {
    tracker: null,
    pluginsReturnedValue: {},
    config,
  })
  let value = {
    startTracking: () => dispatch({ type: 'start' }),
    initTracker: () => dispatch({ type: 'init' }),
    logEvent: (evnt) => dispatch({ type: 'logEvent', payload: evnt }),
    logIssue: (evnt) => dispatch({ type: 'logIssue', payload: evnt }),
    pluginsReturnedValues: { ...state.pluginsReturnedValue },
  }
  return (
    <TrackerContext.Provider value={value}>{children}</TrackerContext.Provider>
  )
}
```
