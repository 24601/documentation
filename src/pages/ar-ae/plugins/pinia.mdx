---
العنوان: "Pinia"
metaTitle: "Pinia"
metaDescription: "البرنامج الإضافي Pinia لـ OpenReplay."
---
استيراد Aside من '~/components/Aside.astro'

يتيح لك هذا البرنامج الإضافي تلقي التغييرات/الحالة الخاصة بـ Pinia وفحصها لاحقًا أثناء إعادة تشغيل تسجيلات الجلسة. هذا مفيد جدًا لفهم وإصلاح المشاكل.

<Aside type="tip">
  لدينا أيضًا درسًا مفصلًا حول كيفية استخدام البرنامج الإضافي Pinia لالتقاط حالة تطبيقك عند استخدام هذه المكتبة، يمكنك التحقق منه [هنا](/tutorials/pinia).
</Aside>

## التثبيت


```bash
npm i @openreplay/tracker-vuex
```


## الاستخدام

قم بتهيئة حزمة `@openreplay/tracker` كالمعتاد وقم بتحميل البرنامج الإضافي إليه. استدعاء البرنامج الإضافي وضبط اسم المتجر، وسيقوم هذا بإرجاع نسخة متعقبة مسماة تتمكن من استدعاءها بالمثال المتجر كمدخل لتمكين تعقب هذا المتجر.

### إذا كان موقع الويب هو تطبيق واحد صفحة (SPA)


```js
import OpenReplay from '@openreplay/tracker';
import trackerVuex from '@openreplay/tracker-vuex';
```


### إذا كان التطبيق الإلكتروني منشورًا على الخادم (SSR)


```js
import OpenReplay from '@openreplay/tracker/cjs';
import trackerVuex from '@openreplay/tracker-vuex/cjs';
```


### تعقب متجر Pinia


```js

//...

const tracker = new OpenReplay({
  projectKey: PROJECT_KEY
  // ... options
});

// ...

const examplePiniaStore = useExamplePiniaStore()
const vuexPlugin = tracker.use(trackerVuex(<options>)) // check list of available options below

const piniaStorePlugin = vuexPlugin('STORE NAME') // add a name to your store, 
                                                  // optional (will be randomly generated otherwise)
piniaStorePlugin(examplePiniaStore) // start tracking state updates

// now you can use examplePiniaStore as usual pinia store (destructure values or return it as a whole etc)
```


## الخيارات

يمكنك تخصيص سلوك البرنامج الإضافي بخيارات لتطهير البيانات الخاصة بك. هي مشابهة للخيارات الموجودة في البرنامج الإضافي القياسي `createLogger`.


```js
trackerVuex({
  filter (mutation, state) {
    // returns `true` if a mutation should be logged
    // `mutation` is a `{ type, payload }`
    return mutation.type !== "aBlacklistedMutation";
  },
  transformer (state) {
    // transforms the state before logging it.
    // for example return only a specific sub-tree
    return state.subTree;
  },
  mutationTransformer (mutation) {
    // mutations are logged in the format of `{ type, payload }`
    // we can format it any way we want.
    return mutation.type;
  },
})
```

